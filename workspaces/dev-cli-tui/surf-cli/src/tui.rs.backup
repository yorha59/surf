//! 最小 TUI 骨架，用于 `--tui` 模式。
//!
//! 当前仅提供占位界面，支持按 'q' 或 Esc 退出。
//! 后续迭代将接入实际的扫描与浏览逻辑。

use anyhow::{Context, Result};
use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{backend::CrosstermBackend, Terminal};
use std::io::{stdout, Stdout};

use crate::Args;
use surf_core::{ScanConfig, start_scan, poll_status, cancel};
use std::time::Duration;

/// 运行 TUI 主循环。
///
/// 进入原始模式与备用屏幕，启动事件循环，绘制占位界面，
/// 直到用户按下 'q' 或 Esc 时退出。
pub fn run_tui(_args: &Args) -> Result<()> {
    // 设置终端：进入备用屏幕、原始模式，启用鼠标捕获
    enable_raw_mode().context("enable raw mode")?;
    let mut stdout = stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)
        .context("enter alternate screen and enable mouse capture")?;

    // 创建后端与终端
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend).context("create terminal")?;

    // 主循环
    let result = run_tui_loop(&mut terminal);

    // 恢复终端：离开备用屏幕、禁用原始模式，禁用鼠标捕获
    disable_raw_mode().context("disable raw mode")?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )
    .context("leave alternate screen and disable mouse capture")?;

    result
}

/// TUI 事件循环。
fn run_tui_loop(terminal: &mut Terminal<CrosstermBackend<Stdout>>) -> Result<()> {
    loop {
        // 绘制当前帧
        terminal.draw(|frame| {
            let area = frame.size();
            if area.width < 10 || area.height < 5 {
                // 终端太小，显示警告
                let warning = ratatui::widgets::Paragraph::new("Terminal too small")
                    .style(ratatui::style::Style::default().fg(ratatui::style::Color::Red));
                frame.render_widget(warning, area);
                return;
            }

            // 使用简单的布局：顶部标题、中间提示、底部状态栏
            let chunks = ratatui::layout::Layout::default()
                .direction(ratatui::layout::Direction::Vertical)
                .constraints([
                    ratatui::layout::Constraint::Length(1), // 标题行
                    ratatui::layout::Constraint::Min(1),    // 内容区域
                    ratatui::layout::Constraint::Length(1), // 状态栏
                ])
                .split(area);

            // 标题
            let title = ratatui::widgets::Paragraph::new("Surf TUI (placeholder)")
                .style(ratatui::style::Style::default().fg(ratatui::style::Color::Cyan));
            frame.render_widget(title, chunks[0]);

            // 内容提示
            let content = ratatui::widgets::Paragraph::new(
                "TUI 正在开发中，目前仅支持按 'q' 或 Esc 退出\n\n\
                 后续迭代将实现：\n\
                 • 扫描目录并显示文件列表\n\
                 • 浏览与导航\n\
                 • 安全删除文件",
            )
            .alignment(ratatui::layout::Alignment::Center);
            frame.render_widget(content, chunks[1]);

            // 状态栏
            let status = ratatui::widgets::Paragraph::new("q: 退出 | Esc: 退出")
                .style(ratatui::style::Style::default().fg(ratatui::style::Color::Gray));
            frame.render_widget(status, chunks[2]);
        })?;

        // 处理事件（非阻塞）
        if event::poll(std::time::Duration::from_millis(100))? {
            if let Event::Key(key) = event::read()? {
                // 只处理按键按下事件，避免重复触发
                if key.kind == KeyEventKind::Press {
                    match key.code {
                        KeyCode::Char('q') | KeyCode::Esc => {
                            // 用户请求退出
                            break;
                        }
                        _ => {
                            // 其他按键暂时忽略
                        }
                    }
                }
            }
        }
    }

    Ok(())
}

/// 单元测试：验证 run_tui 函数签名与基本逻辑。
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_run_tui_signature() {
        // 仅验证函数签名能够编译，不实际运行 TUI
        let _ = run_tui;
        assert!(true);
    }
}
